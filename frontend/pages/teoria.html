<!DOCTYPE html>
<html>

<head>
    <title>Учебно-демонстрационная программа по технологии "WebRTC"</title>
    <meta charset="utf-8" />
    <link href="css/style.css" rel="stylesheet">
</head>

<body>

    <div class="menu">
        <div class="menubutton"><a href="/theory">Теория</a></div>
        <div class="menubutton"><a href="/">Демо</a></div>
    </div>

    <div class="header">
        <div>Теория</div>
    </div>

    <div class="main">
        <h2>Технология</h2>
        <p><b>WebRTC (англ. real-time communications — коммуникации в реальном времени)</b> — проект с открытым исходным кодом, предназначенный для организации передачи потоковых данных между браузерами или другими поддерживающими его приложениями по технологии точка-точка.</p>
        <p>Технология <b>WebRTC</b> делает возможной видеосвязь через окно браузера, так что для присоединения к звонку необходимо только перейти по ссылке на соответствующую веб-страницу.</p>
        <p>В WebRTC используются два аудиокодека, G.711 и Opus, а также видеокодеки VP8 и H.264.</p>
        <hr>
        <h3>Преимущества технологии</h3>
        <ul>
            <li>проведение конференции в браузере значительно упрощает процесс проведения конференции — пользователю не нужно устанавливать для этого отдельные приложения;</li>
        </ul>
        <ul>
            <li>используемые кодеки обеспечивают хорошее качество связи;</li>
        </ul>
        <ul>
            <li>возможность реализации любых элементов интерфейса средствами HTML5 и JavaScript;</li>
        </ul>
        <ul>
            <li>открытый исходный код даёт больше возможностей для использования.</li>
        </ul>
        <hr>
        <h3>Недостатки технологии</h3>
        <ul>
            <li>технология определяет только общий стандарт передачи данных (видео и звука), но отдельные решения разных браузеров относительно адресации абонентов и прочих управляющих процессов не совместимы между собой. Поэтому даже звонки между парой различных браузеров представляют отдельную сложность.</li>
        </ul>
        <ul>
            <li>обеспечение групповых конференций требует дополнительных разработок поверх WebRTC.</li>
        </ul>
        <hr>
        <h3>Основные возможности технологии</h3>
        <ul>
            <li>Захват изображения с веб-камеры</li>
        </ul>
        <ul>
            <li>Захват звука с микрофона</li>
        </ul>
        <ul>
            <li>Захват изображения с экрана компьютера (весь экран или окно приложения)</li>
        </ul>
        <ul>
            <li>Видео- и аудиосвязь</li>
        </ul>
        <ul>
            <li>Передача данных (текст и файлы)</li>
        </ul>
        <ul>
            <li>DTLS-SRTP шифрование</li>
        </ul>
        <hr>
        <h2>Поддержка в браузерах</h2>
        <p>Chrome: 23+</p>
        <p>Safari: 11+</p>
        <p>Firefox: 38+</p>
        <p>Opera: 12+</p>
        <hr>
        <h2>Работа с технологией</h2>
        <p><b>WebRTC</b> - это JavaScript API, встроенный в браузер. Он состоит из трех главных компонентов.</p>
        <ul>
            <li><b>Media Streams</b> – позволяет получить доступ к камере и микрофону через браузер.</li>
        </ul>
        <ul>
            <li><b>RTCPeerConnection</b> – позволяет установить Peer-to-Peer соединение между браузерами.</li>
        </ul>
        <ul>
            <li><b>RTCDataChannel</b> – позволяет осуществлять двунаправленную передачу произвольных данных (файлов).</li>
        </ul>
        <hr>
        <h3>Алгоритм получения видео- и аудиопотоков пользователя.</h3>
        <p>
            <textarea style="width: 850px; height: 200px; resize: none; font-family: Courier New;" readonly>
  let stream; // переменная для прямого видео/аудио потока
  let streamConstraints = { "audio": true, "video": true }; // параметры стрима
  try {
      stream = await navigator.mediaDevices.getUserMedia(streamConstraints);
      localVideo.srcObject = stream;	// localVideo — html-объект видео
  } catch(error) {
      ...
      // действия в случае ошибки //
  }
    </textarea>
        </p>
        <hr>
        <h3>Соединение и сигнальный сервер</h3>
        <p>Клиенты оперируют некими "приглашением" и "ответом", в которых содержится важная информация о будущем соединении.</p>
        <p>Клиент 1 (приглашающий) создает приглашение и передает его Клиенту 2 (отвечающий).</p>
        <p>Клиент 2, принимая приглашение, генерирует ответ и отправляет его Клиенту 1.</p>
        <p>После этого устанавливается peer-to-peer соединение, то есть одноранговая сеть без посредников и серверов, напрямую.</p>
        <p>В стандарте технологии способ передачи приглашения и ответа никак не регламентируется и должно организовываться силами разработчика приложения, использующего WebRTC.</p>
        <p>Эта передача называется <b>сигнализацией</b>.</p>
        <p>Часто для автоматизации используется сигнальный сервер, который пересылает приглашение и ответ между клиентами.</p>
        <p>Но сигнализацию можно провести и вручную, например по электронной почте или мессенджеру (Discord, Skype).</p>
        <p>На рисунке ниже представлена схема такого соединения.</p>
        <p><img src="img/p2p-connection.jpg"></p>
        <hr>
        <h3>SDP-объект</h3>
        <p><b>SDP-объект (Session Description Protocol)</b> — это «приглашение» и «ответ» клиентов.</p>
        <p>В нем содержится информация: </p>
        <ul>
            <li>о доступных способах кодирования видео и аудио данных;</li>
        </ul>
        <ul>
            <li>поддерживаемом транспортном протоколе;</li>
        </ul>
        <ul>
            <li>ICE-кандидатах и прочих возможностях;</li>
        </ul>
        <p><b>SDP</b> – текстовые данные в формате ключ-значение.</p>
        <hr>
        <h3>ICE-кандидат</h3>
        <p><b>ICE-кандидат</b> – объект, описывающий возможности соединения браузера (IP + Port).</p>
        <hr>
        <h3>Алгоритм создания RTCPeerConnection.</h3>
        <p>
            <textarea style="width: 850px; height: 200px; resize: none; font-family: Courier New;" readonly>
  let pc; // переменная для peer-соединения

  // переменная с конфигурацией для ice-кандидатов
  let configuration = { "iceServers": [ { "urls": "stun:stun.l.google.com:19302" } ]};
  pc = new RTCPeerConnection(this.configuration); // создаем RTCPeerConnection

  // передаем локальный медиапоток в pc
  stream.getTracks().forEach(track =&gt; pc.addTrack(track, stream));
    </textarea>
        </p>
        <hr>
        <h3>Алгоритм создания приглашения</h3>
        <p>
            <textarea style="width: 850px; height: 200px; resize: none; font-family: Courier New;" readonly>
  Вызвать «Алгоритм создания RTCPeerConnection»

  // создаем приглашение и устанавливаем его как описание локальной стороны
  try {
      const offer = await pc.createOffer(this.offerOptions);
      await pc.setLocalDescription(offer);
  } catch(error) {
      ...
      // действия в случае ошибки
  }
    </textarea>
        </p>
        <hr>
        <h3>Алгоритм получения приглашения и создания ответа</h3>
        <p>
            <textarea style="width: 850px; height: 200px; resize: none; font-family: Courier New;" readonly>
  Вызвать «Алгоритм создания RTCPeerConnection»

  // каким-либо образом читаем SDP-объект из приглашения
  const desc = readSDPfromOffer();

  // устанавливаем приглашение как описание удаленной стороны
  и запрашиваем формирования ответа
  try {
      await pc.setRemoteDescription(desc);
      const answer = await this.pc.createAnswer();
      await pc.setLocalDescription(answer);
  } catch (error) {
      ...
      // действия в случае ошибки
  }
    </textarea>
        </p>
        <hr>
        <h3>Алгоритм приема ответа</h3>
        <p>
            <textarea style="width: 850px; height: 200px; resize: none; font-family: Courier New;" readonly>
  // каким-либо образом читаем SDP-объект из ответа
  const desc = readSDPfromAnswer();

  // устанавливаем приглашение как описание удаленной стороны
  и запрашиваем формирования ответа
  try {
      await pc.setRemoteDescription(desc);
  } catch (error) {
      ...
      // действия в случае ошибки
  }
    </textarea>
        </p>
        <p></p>
        <p></p>
        <p></p>
    </div>

</body>

</html>